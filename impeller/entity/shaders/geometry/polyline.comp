// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
layout(local_size_x = 1024, local_size_y = 1) in;
layout(std430) buffer;

#include <impeller/path.glsl>
#include <impeller/prefix_sum.glsl>

#define MEMORY_SIZE 1024

struct IndexDataItem {
  uint first_offset;
  uint indirect_offset;
};

struct IndirectCommandArguments {
  uint vertex_count;
  uint instance_count;
  uint vertex_start;
  uint base_instance;
};

layout(binding = 0) readonly buffer Quads {
  QuadData data[];
}
quads;

layout(binding = 1) readonly buffer IndexData {
  IndexDataItem data[];
}
index_data;

layout(binding = 2) readonly buffer Lines {
  LineData data[];
}
lines;

layout(binding = 3) readonly buffer Components {
  PathComponent data[];
}
components;

layout(binding = 4) writeonly buffer Polyline {
  vec2 data[];
}
polyline;

layout(binding = 5) writeonly buffer OutputIndexData {
  IndexDataItem data[];
}
index_output_data;

layout(binding = 6) writeonly buffer OutputConfig {
  uint count;
}
output_config;

uniform Config {
  uint input_count;
}
config;

shared uint storage[MEMORY_SIZE];

void main() {
  uint ident = gl_GlobalInvocationID.x;

  uint count = 0;
  QuadData quad;
  LineData line;
  QuadDecomposition decomposition;

  if (ident < config.input_count) {
    PathComponent component = components.data[ident];

    if (component.count == 2) {
      line = lines.data[component.index];
      count = 2;
    } else {
      quad = quads.data[component.index];
      decomposition = DecomposeQuad(quad, 0.1);

      if (decomposition.line_count == 1) {
        count = 2;
        line = LineData(quad.p1, quad.p2);
      } else {
        count = 2 + decomposition.line_count;
      }
    }
  }

  storage[ident] = count;
  barrier();

  ExclusivePrefixSum(ident, storage, MEMORY_SIZE);
  uint idx = storage[ident];

  if (count == 0) {
    return;
  }

  IndexDataItem index_data = index_data.data[ident];
  IndexDataItem output_index_data = IndexDataItem(
      storage[index_data.first_offset], index_data.indirect_offset);


  if (count == 2) {
    polyline.data[idx] = line.p1;
    polyline.data[idx + 1] = line.p2;

    index_output_data.data[idx] = output_index_data;
    index_output_data.data[idx + 1] = output_index_data;
  } else {
    polyline.data[idx] = quad.p1;
    index_output_data.data[idx] = output_index_data;

    for (uint i = 0; i <= decomposition.line_count; i++) {
      polyline.data[idx + i + 1] = GenerateLineFromQuad(quad, i, decomposition);
      index_output_data.data[idx + i + 1] = output_index_data;
    }

    polyline.data[idx + count + 1] = quad.p2;
    index_output_data.data[idx + count + 1] = output_index_data;
  }
  atomicAdd(output_config.count, count);
}

//
//
// Line Segment
// p1         p2      | count = 2
//
//
// Quad Segment
//
// p1          p2      | count = 2
//    s1 s2 sn         |   + N subdivisions
//
// As long as we're on the same contour, then P2 == P1 of the next line segment.